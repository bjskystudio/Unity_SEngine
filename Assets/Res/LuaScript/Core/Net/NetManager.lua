---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by asd.
--- DateTime: 2022/12/28 18:30
---
local PBManager = require("PBManager")
local Log = require("Log")
local ProtocolEnum = require("ProtocolEnum")
local EventManager = require("EventManager")
local GameEvent = require("GameEvent")
local GameData = require("GameData")
local json = require("json")

---@class NetManager : Singleton lua网络连接组件
local NetManager = Class("NetManager", Singleton)

---@class NetManager.eNetState 连接状态
NetManager.eNetState = {
    Connect = 1,
    Close = 2,
    Timeout = 3,
    Error = 4
}


---生成新的流水号
function NetManager:NewSerialNumber()
    if self.SerialNumber >= 32767 then
        self.SerialNumber = 0
    end

    self.SerialNumber = self.SerialNumber + 1
    return self.SerialNumber
end
function NetManager:__init()
    self.CSNet = CS.Game.Network.NetworkKit
    self.CSNet.Init()

    ---流水号，计算用，外部禁止使用
    self.SerialNumber = 0
    ---接收消息处理函数表
    self.tabRecvFunc = {}
    ---@type table<number,NetSendData> 等待回调的请求
    self.tabWaitRecive = {}
    ---接受推送消息的列表
    self.tabPushRecvFunc = {}
    ---收到系统错误时处理函数表
    self.tabErrFunc = {}

end

---连接服务器
---@param account string
---@param password string
function NetManager:ConnectServer(account,password)
    if self.IsConnected ~= true then
        local postData = {
            username = account,
            password = password,
        }
        local jsonStr = json.encode(postData)
        self.CSNet.SendServerHttpRequest(AppSetting.ServerConfig.ServerHttp_Url,jsonStr,function(state,msg)
            if state == 1 then
                Log.Info("Server Http Response:\n"..msg)
                local resp = json.decode(msg)
                self:OnHttpResponse(resp.data)
            else
                ---http错误
                EventManager:GetInstance():Broadcast(GameEvent.HttpResponseError,"Server Http error!")
            end
        end)
    else
        EventManager:GetInstance():Broadcast(GameEvent.ServerConnected,"server is connected")
    end
end

---@param data HttpServerResponse
---@param success fun()
function NetManager:OnHttpResponse(data)
    GameData:GetInstance():CheckAccount(data)
    self.CSNet.Connect(data.gate_ip,data.gate_port,function(state,msg)
        if state == NetManager.eNetState.Connect then
            self.IsConnected = true
            EventManager:GetInstance():Broadcast(GameEvent.ServerConnected,msg)
        elseif state == NetManager.eNetState.Close then
            EventManager:GetInstance():Broadcast(GameEvent.ServerClosed,msg)
        elseif state == NetManager.eNetState.Timeout then
            EventManager:GetInstance():Broadcast(GameEvent.ServerConnectTimeout,msg)
        elseif state == NetManager.eNetState.Error then
            EventManager:GetInstance():Broadcast(GameEvent.ServerConnectError,msg)
        end
    end)
end


---发送数据
---@param cmd ProtocolEnum 发送的协议cmd
---@param reqParam table 发送数据
---@param ackCmd ProtocolEnum 接收的协议cmd
---@param okCB fun(ackParam:table, reqParam:table) @接收函数 参数是send的args和响应table
---@param errCB fun(ackParam:string, reqParam:table) @错误处理函数 参数是send的args和错误码，返回是否成功处理数据
function NetManager:SendMsg(cmd,reqParam,ackCmd,okCB,errCB)
    local protoName = ProtocolEnum.packageName
            .. "." .. ProtocolEnum.MessageName[cmd]
    local bytes = PBManager:GetInstance():Encode(protoName, reqParam)


    if ackCmd ~= nil and ackCmd > 0 then
        ---需要等待回调
        local sn = self:NewSerialNumber()
        ---保存一次原始数据，用于重发或验证
        ---@type NetSendData
        local sendData = {
            cmd = cmd,
            reqParam = reqParam,
            ackCmd = ackCmd or 0,
            okCB = okCB or nil,
            errCB = errCB or nil,
            SerialNumber = sn
        }
        self.tabWaitRecive[sn] = sendData
    else
        if okCB then
            okCB(nil,reqParam)
        end
    end
    self.CSNet.SendLua(cmd,bytes)
end

---注册消息回调
---@param cmd ProtocolEnum 接受的协议cmd
---@param okCB fun(ackParam:table, reqParam:table) @接收函数 参数是send的args和响应table
---@param errCB fun(ackParam:string, reqParam:table) @错误处理函数 参数是send的args和错误码，返回是否成功处理数据
function NetManager:RegisterMsg(cmd,okCB,errCB)
    self.tabRecvFunc[cmd] = okCB
    self.tabErrFunc[cmd] = errCB
end

---注册推送消息
function NetManager:RegisterPushMsg(cmd,okCB)
    self.tabPushRecvFunc[cmd] = okCB
end


---@param cmd ProtocolEnum 接受的协议cmd
---@param bytes any
function NetManager:OnRecvMessage(cmd,bytes)
    Log.Info("收到消息cmd："..cmd);
    local protoName = ProtocolEnum.packageName
            .. "." .. ProtocolEnum.MessageName[cmd]
    --反序列化

    local askParam = PBManager:GetInstance():Decode(protoName, bytes)
    if self.tabPushRecvFunc[cmd] ~= nil then
        --是推送消息
        self.tabPushRecvFunc[cmd](askParam,nil)
        return
    end
    if self.tabRecvFunc[cmd] ~= nil then
        for i, v in pairs(self.tabWaitRecive) do
            if v.ackCmd == cmd then
                local reqParam = v.reqParam
                --处理逻辑
                self.tabRecvFunc[cmd](askParam,reqParam)
                if v.okCB ~= nil then
                    --响应回调
                    v:okCB(askParam,reqParam)
                end
                self.tabWaitRecive[i] = nil
                break
            end
        end
    end

end

return NetManager
---@class NetSendData
---@field SerialNumber number 流水号
---@field reqParam table 发送数据
---@field cmd ProtocolEnum
---@field ackCmd ProtocolEnum
---@field okCB function 收到响应，处理数据之后的界面回调，可为nil
---@field errCB function 收到错误响应，处理数据之后的界面回调，可为nil

---@class HttpServerResponse http服务器回调
---@field account string 账号
---@field extra_data string
---@field game_id string
---@field gate_id string
---@field gate_ip number gate_ip
---@field gate_port number 端口
---@field identify_state number
---@field isnewuserid boolean
---@field iso_code string
---@field mergeremsecond number
---@field mergetxt string
---@field name string
---@field password string
---@field server_id string
---@field token string
---@field user_id string